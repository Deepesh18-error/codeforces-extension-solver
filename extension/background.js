/**
 * Codeforces AI Solver - Background Script (Service Worker)
 *
 * This script acts as the "Central Hub" or "HQ" for the extension.
 * It is the persistent brain of the application.
 *
 * Phase 1 Responsibilities:
 * 1. Listen for a 'solveProblem' message from the content script.
 * 2. Receive the scraped problem data.
 * 3. Log this data to the console for developer verification (The "Report").
 * 4. Call a "stub" function that returns a hardcoded, placeholder solution.
 * 5. Send this placeholder solution back to the content script that made the request.
 */

console.log("--- Background Script (HQ) is online. Awaiting missions. ---");

// This is the main listener for all messages coming into the HQ.
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  // We use the message 'type' to know what action to take.
  if (message.type === 'solveProblem') {
    console.log("--- HQ: 'solveProblem' mission received. ---");
    console.log("HQ: Report received from agent in tab:", sender.tab.id);

    // This function contains our "stubbed" logic for Phase 1.
    // We've made it async to prepare for Phase 2, where it will make a real network call.
    handleSolveProblem(message.data)
      .then(solution => {
        console.log("HQ: Sending placeholder solution back to the agent.");
        // Responding to the agent with the result.
        sendResponse({ code: solution });
      })
      .catch(error => {
        console.error("HQ: An error occurred in the mission.", error);
        // Send an error response back if something goes wrong.
        sendResponse({ error: "Failed to process the request." });
      });

    // IMPORTANT: Return 'true' to indicate that we will be sending a response asynchronously.
    // This keeps the message channel open until sendResponse() is called.
    return true;
  }
});

/**
 * The API Call Stub for Phase 1.
 * In later phases, this function will contain the `fetch()` call to our actual backend server.
 *
 * @param {object} problemData - The data object scraped from the content script.
 * @returns {Promise<string>} A promise that resolves with a hardcoded solution string.
 */
async function handleSolveProblem(problemData) {
  // Task 1: Print the data to the console for verification.
  console.log("--- HQ: Verifying received data from agent ---");
  console.log("Title:", problemData.title);
  console.log("Sample Tests Found:", problemData.samples.length);
  // You can uncomment the line below for full details during debugging
  // console.log("Full Data:", problemData);

  // Task 2: Return a hardcoded, placeholder string of code.
  // We add a small delay to simulate a network request, making the UI feedback feel more real.
  await new Promise(resolve => setTimeout(resolve, 1500)); // 1.5 second delay

  const placeholderSolution = `// This is a placeholder solution from the Phase 1 HQ (background.js)
// Problem Title: ${problemData.title}
//
// In Phase 2, this code will be generated by a real AI!

#include <iostream>
#include <vector>
#include <string>

void solve() {
    // The logic to solve "${problemData.title}" will be generated here.
    std::cout << "Hello, World!" << std::endl;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    solve();
    return 0;
}
`;

  return placeholderSolution;
}