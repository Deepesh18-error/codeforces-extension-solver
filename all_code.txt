--- .\j.py ---
import os

# List of code file extensions to include
CODE_EXTENSIONS = ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.cs', '.rb', '.go', '.php', '.html', '.css']

def should_include_file(filepath):
    # Exclude anything in node_modules
    return 'node_modules' not in filepath and os.path.splitext(filepath)[1] in CODE_EXTENSIONS

def main():
    with open('all_code.txt', 'w', encoding='utf-8') as out_file:
        for root, dirs, files in os.walk('.'):
            # Skip node_modules directories
            dirs[:] = [d for d in dirs if d != 'node_modules']
            for file in files:
                filepath = os.path.join(root, file)
                if should_include_file(filepath):
                    try:
                        with open(filepath, 'r', encoding='utf-8') as src:
                            out_file.write(f'--- {filepath} ---\n')
                            out_file.write(src.read())
                            out_file.write('\n\n')
                        print(f'Added: {filepath}')
                    except Exception as e:
                        print(f'Error processing {filepath}: {e}')

if __name__ == '__main__':
    main()

--- .\extension\background.js ---
// File: extension/background.js (FINAL ARCHITECTURE - Updated for flexible navigation)

console.log("--- Background Script (HQ) is online. ---");

/**
 * Fetches the AI solution from the backend server and, upon success,
 * stores the solution code in chrome.storage.local for the content script to pick up.
 * @param {object} problemData - The problem data scraped from the page.
 */
async function getSolutionAndStoreIt(problemData) {
  const serverUrl = 'http://localhost:3000/api/solve';
  console.log(`HQ: Contacting server at ${serverUrl} to solve "${problemData.title}"...`);
  try {
    const response = await fetch(serverUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(problemData)
    });

    if (!response.ok) {
      throw new Error(`Server responded with status: ${response.status}`);
    }

    const data = await response.json();

    if (data.solution) {
      console.log("HQ: Solution received. Storing it for the content script to paste.");
      // Key step: Save the final code to storage. The content script is listening for this.
      chrome.storage.local.set({ solutionToPaste: data.solution });
    } else {
      throw new Error("Server response did not contain a 'solution' key.");
    }
  } catch (error) {
    console.error('HQ: Fetch to backend or storage failed:', error);
    // If anything fails, we still store an error message so the user sees the problem.
    chrome.storage.local.set({ solutionToPaste: `// Error: Failed to get solution.\n// Reason: ${error.message}` });
  }
}

// ==========================================================
//  Main Message Listener (UPDATED to handle conditional navigation)
// ==========================================================
chrome.runtime.onMessage.addListener((message, sender) => {
    // This is the ONLY message type we expect from the problem page.
    if (message.type === 'getSolutionAndPrepareToPaste') {
        
        // 1. Start the AI fetch process. This runs for both workflows.
        console.log("HQ: Received mission. Will fetch solution in the background.");
        getSolutionAndStoreIt(message.data);

        // 2. Conditionally navigate the user's tab.
        // This ONLY runs if the content script provided a URL (i.e., the "Contest" workflow).
        if (message.submitUrl) {
            console.log("HQ: Navigating user's tab to a specific URL provided by content script.");
            chrome.tabs.update(sender.tab.id, { url: message.submitUrl });
        } else {
            // For the "Problemset" workflow, the content script handles the navigation by clicking a link,
            // so the background script does nothing here.
            console.log("HQ: No submitUrl provided. Navigation is being handled by the content script.");
        }
    }
});

--- .\extension\content_script.js ---

// File: extension/content_script.js (FINAL, with Robust URL Handling)
(() => {
    console.log(`[AI SOLVER] Script INJECTED on ${window.location.href}`);

    // ==========================================================
    //  HELPER FUNCTIONS
    // ==========================================================

    const TRACKING_CLASS = 'cf-highlighter-tracking';
    const ACCEPTED_CLASS = 'cf-highlighter-accepted';
    const REJECTED_CLASS = 'cf-highlighter-rejected';
    const ANALYZING_TEXT_SPAN_CLASS = 'cf-highlighter-status-indicator';
    const COPY_BUTTON_CLASS = 'cf-highlighter-copy-btn';


    // ADD this helper function
    function getLoggedInUser() {
        const profileLink = document.querySelector('#header .lang-chooser a[href^="/profile/"]');
        return profileLink ? profileLink.textContent.trim() : null;
    }

    const injectPasterScript = () => {
        if (document.getElementById('ai-solver-paster-script')) return;
        const script = document.createElement('script');
        script.id = 'ai-solver-paster-script';
        script.src = chrome.runtime.getURL('injector.js');
        (document.head || document.documentElement).appendChild(script);
        console.log('[AI SOLVER] Paster script has been injected into the page.');
    };

    const waitForElement = (selector, callback, timeout = 15000) => {
        let intervalId = null;
        const failSafe = setTimeout(() => {
            clearInterval(intervalId);
            console.warn(`[AI SOLVER] FAILED: waitForElement timed out after ${timeout / 1000}s for '${selector}'`);
        }, timeout);

        intervalId = setInterval(() => {
            const el = document.querySelector(selector);
            if (el) {
                clearInterval(intervalId);
                clearTimeout(failSafe);
                callback(el);
            }
        }, 100);
    };


    //  LOGIC FOR PROBLEM PAGE

    const scrapeProblemData = () => {
        try {
            const titleEl = document.querySelector(".problem-statement .title") ||
                            document.querySelector(".problem-frames-wrapper .title") ||
                            document.querySelector("div.header > div.title");

            const statementEl = document.querySelector(".problem-statement > div:nth-child(2)");

            if (!titleEl || !statementEl) {
                console.error("[AI SOLVER] Scraper: Missing title or statement.");
                return null;
            }

            const title = titleEl.innerText.replace(/^[A-Z1-9]+\.\s*/, "").trim();
            const statement = statementEl.innerHTML;

            const samples = Array.from(document.querySelectorAll(".sample-test")).map((test) => {
                const inEl = test.querySelector(".input pre");
                const outEl = test.querySelector(".output pre");
                return inEl && outEl ? { input: inEl.innerText, output: outEl.innerText } : null;
            }).filter(Boolean);

            return { title, statement, samples };
        } catch (err) {
            console.error("[AI SOLVER] Error during scraping:", err);
            return null;
        }
    };

    const injectSolveButton = (targetElement) => {
        if (document.getElementById("ai-solve-button")) return;

        const btn = document.createElement("button");
        btn.id = "ai-solve-button";
        btn.textContent = "Solve with AI";
        Object.assign(btn.style, {
            backgroundColor: "#4CAF50",
            color: "white",
            padding: "8px 16px",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
            marginLeft: "15px",
        });

        btn.addEventListener("click", handleSolveButtonClick);
        targetElement.insertAdjacentElement("afterend", btn);
    };


    //  CLICK HANDLER FOR SOLVE BUTTON

    const handleSolveButtonClick = () => {
        console.log('[AI SOLVER] Solve button clicked.');
        const data = scrapeProblemData();

        if (!data) {
            alert('AI Solver: Failed to scrape problem data.');
            return;
        }

        const url = window.location.href;

        // --- Workflow 1: Contest or Gym Problem ---
        if (url.includes('/contest/') || url.includes('/gym/')) {
            const match = url.match(/\/(contest|gym)\/(\d+)\/problem\/([A-Z]\d*)/);
            if (match) {
                const [_, type, contestId, problemIndex] = match;
                const submitUrl = `https://codeforces.com/${type}/${contestId}/submit?submittedProblemIndex=${problemIndex}`;
                console.log(`[AI SOLVER] Contest/Gym workflow detected. Navigating to: ${submitUrl}`);
                chrome.runtime.sendMessage({
                    type: 'getSolutionAndPrepareToPaste',
                    data: data,
                    submitUrl: submitUrl,
                });
                return;
            }
        }

        // --- Workflow 2: Problemset Problem ---
        if (url.includes('/problemset/problem/')) {
            const submitLink = document.querySelector('a[href$="/submit"], a[href^="submit"]');
            if (submitLink) {
                console.log("[AI SOLVER] Problemset workflow detected. Clicking page's submit link.");
                chrome.runtime.sendMessage({ type: 'getSolutionAndPrepareToPaste', data: data });
                submitLink.click();
                return;
            } else {
                alert("AI Solver: Could not find the 'Submit' link on the page for this problemset problem.");
                return;
            }
        }

        // --- Fallback Error ---
        alert('AI Solver: Could not recognize the URL format (not a contest, gym, or problemset page).');
    };


    //  LOGIC FOR SUBMIT AND STATUS PAGES

    const initSubmitPageLogic = () => {
        console.log("[AI SOLVER] Submit page detected. Initializing logic for pasting and submission tracking.");
        injectPasterScript();

        const dispatchPasteEvent = (solution) => {
            if (!solution || typeof solution !== 'string') return;
            console.log('[AI SOLVER] Dispatching event with solution to the injected script.');
            window.dispatchEvent(new CustomEvent('pasteSolutionIntoCodeforcesEditor', {
                detail: { code: solution }
            }));
            chrome.storage.local.remove('solutionToPaste');
        };

        chrome.storage.local.get('solutionToPaste', (result) => {
            if (result && result.solutionToPaste) {
                dispatchPasteEvent(result.solutionToPaste);
            }
        });

        const storageListener = (changes, namespace) => {
            if (namespace === 'local' && changes.solutionToPaste) {
                console.log("[AI SOLVER] Listener detected a solution has arrived.");
                dispatchPasteEvent(changes.solutionToPaste.newValue);
                chrome.storage.onChanged.removeListener(storageListener);
            }
        };

        chrome.storage.onChanged.addListener(storageListener);

        console.log("[AI SOLVER] Setting up submission tracker.");
        waitForElement('input[type="submit"][value="Submit"]', (submitButton) => {
            console.log("[AI SOLVER] Found the final 'Submit' button. Attaching click listener.");
            submitButton.addEventListener('click', () => {
                console.log("[AI SOLVER] 'Submit' button clicked! Setting 'isAwaitingVerdict' flag in storage.");
                chrome.storage.local.set({
                    isAwaitingVerdict: true,
                    submissionTimestamp: Date.now()
                });
            });
        });
    };

    // REPLACE your current initStatusPageLogic with this correct version

// REPLACED FUNCTION
//  START OF THE FINAL CORRECTED FUNCTION


const initStatusPageLogic = () => {
    // Stage 1: Wait for the main content container of the entire page.
    // This ensures the page is ready for us to look for more specific elements.
    console.log('[AI SOLVER] Status page detected. Waiting for main page content to load...');
    
    waitForElement('div#pageContent', (pageContent) => {
        console.log('[AI SOLVER] Main page content loaded. Now waiting for the submission table...');

        // Stage 2: Now that the page is ready, wait for the specific submissions table.
        waitForElement('.status-frame-datatable', (tableElement) => {
            console.log('[AI SOLVER] SUCCESS: Submission table found! Initializing core logic.');

            // All the logic from before now runs safely inside this callback.
            const startMonitoringById = (submissionId) => {
                console.log(`[AI SOLVER] Now monitoring AI submission ID #${submissionId}`);
                initVerdictHighlighter(submissionId, tableElement); 
            };

            chrome.storage.local.get(['isAwaitingVerdict'], (result) => {
                if (result && result.isAwaitingVerdict) {
                    console.log('[AI SOLVER] "isAwaitingVerdict" flag is true.');
                    chrome.storage.local.remove('isAwaitingVerdict');

                    const firstRow = tableElement.querySelector('tbody tr[data-submission-id]');
                    if (firstRow) {
                        const newSubmissionId = firstRow.getAttribute('data-submission-id');
                        startMonitoringById(newSubmissionId);
                    } else {
                        console.warn('[AI SOLVER] Awaiting verdict, but no submission rows found.');
                    }
                } else {
                    console.log('[AI SOLVER] No pending AI submission. Initializing general highlighter.');
                    initVerdictHighlighter(null, tableElement);
                }
            });
        });
    });
};

//  END OF THE FINAL, BULLETPROOF FUNCTION



    const initVerdictHighlighter = (submissionIdToTrack = null) => {
    // If we passed a specific ID, we use it. Otherwise, targetSubmissionID is null and the old logic runs.
    let targetSubmissionID = submissionIdToTrack; 
    
    // If we are already tracking a specific ID, we can log it and skip the initial detection phase.
    if(targetSubmissionID) {
         console.log(`[AI SOLVER] Highlighter has been given a specific ID to track: #${targetSubmissionID}`);
         // We can immediately apply the tracking style
         const row = document.querySelector(`tr[data-submission-id="${targetSubmissionID}"]`);
         if (row) row.classList.add(TRACKING_CLASS);
    } else {
        console.log('[AI SOLVER] Advanced Verdict Highlighter module initialized (general mode).');
    }

    let mutationTimeout = null;

    // ... onMutation and handleVerdictCheck remain the same ...
    const onMutation = () => {
        clearTimeout(mutationTimeout);
        mutationTimeout = setTimeout(handleVerdictCheck, 100);
    };
    
    const handleVerdictCheck = () => {
        if (targetSubmissionID === null) checkForNewSubmission();
        else monitorTrackedSubmission();
    };
    
  const checkForNewSubmission = () => {
    const topRow = document.querySelector('.datatable tbody tr[data-submission-id]'); // CHANGED: More robust selector
    if (!topRow) return;
    const submissionId = topRow.getAttribute('data-submission-id');
    const verdictCell = topRow.querySelector('.status-verdict-cell');
    if (!submissionId || !verdictCell) return;
    const verdictText = verdictCell.textContent.trim();
    const isLive = verdictText.includes('In queue') || verdictText.includes('Running');
    if (isLive) {
      targetSubmissionID = submissionId;
      topRow.classList.add(TRACKING_CLASS); // Use the new black border style
      console.log(`[CF Highlighter] Phase 1: New submission detected. Now watching ID: ${targetSubmissionID}`);
    }
  };
    
    const resetState = () => { targetSubmissionID = null; };
    
    const monitorTrackedSubmission = () => {
        const trackedRow = document.querySelector(`tr[data-submission-id="${targetSubmissionID}"]`);
        if (!trackedRow) {
            resetState();
            return;
        }

        const verdictCell = trackedRow.querySelector('.status-verdict-cell');
        if (!verdictCell) return;

        const verdictSpan = verdictCell.querySelector('span[waiting]');
        const verdictText = verdictCell.textContent.trim();
        const isFinal = (verdictSpan && verdictSpan.getAttribute('waiting') === 'false') ||
                        (verdictText && !verdictText.includes('Running') && !verdictText.includes('In queue'));

        if (isFinal) {
            console.log(`[AI SOLVER] Highlighter: Final verdict for #${targetSubmissionID}: "${verdictText}"`);
            trackedRow.classList.remove(TRACKING_CLASS);

            if (verdictText.toLowerCase().includes('accepted')) {
                trackedRow.classList.add(ACCEPTED_CLASS);
            } else {
                trackedRow.classList.add(REJECTED_CLASS);

                let isUserSubmission = false;
                

                // <<< FIX #1: This check is now universal for all "My Submissions" pages.

                const onMySubmissionsPage = window.location.href.includes('my=on') || window.location.pathname.endsWith('/my');

                if (onMySubmissionsPage) {
                    console.log("[AI SOLVER] On 'My Submissions' page. Assuming submission belongs to user.");
                    isUserSubmission = true;
                } else {
                    const loggedInUser = getLoggedInUser();
                    

                    // <<< FIX #2: Using the correct selector to find the author's name.

                    const authorElement = trackedRow.querySelector('td.status-party-cell a');
                    
                    const submissionAuthor = authorElement ? authorElement.textContent.trim() : null;
                    
                    console.log(`[AI SOLVER] On general status page. Comparing loggedInUser='${loggedInUser}' with submissionAuthor='${submissionAuthor}'`);
                    if (loggedInUser && submissionAuthor && loggedInUser === submissionAuthor) {
                        isUserSubmission = true;
                    }
                }

                // Now, we check the final boolean result.
                if (isUserSubmission) {
                    console.log(`[AI SOLVER] User ownership confirmed. Proceeding to scrape.`);
                    const isActionable = verdictText.toLowerCase().includes('wrong answer') || verdictText.toLowerCase().includes('time limit exceeded');
                    const match = verdictText.match(/on test (\d+)/);

                    if (isActionable && match) {
                        const failedTestNumber = match[1];
                        const statusSpan = document.createElement('span');
                        statusSpan.className = ANALYZING_TEXT_SPAN_CLASS;
                        statusSpan.textContent = ' (Analyzing...)';
                        verdictCell.appendChild(statusSpan);
                        startPhase2_DataAcquisition(targetSubmissionID, failedTestNumber);
                    }
                } else {
                    console.log(`[AI SOLVER] Scraper not activated. Submission does not belong to logged-in user.`);
                }
            }
            resetState();
        }
    };


    
    const startPhase2_DataAcquisition = async (submissionId, failedTestNumber) => {
        try {
            const csrfToken = document.querySelector('.csrf-token')?.dataset?.csrf;
            if (!csrfToken) throw new Error("CSRF token not found.");
            
            const url = `https://codeforces.com/data/submitSource`;
            const formData = new FormData();
            formData.append('submissionId', submissionId);
            formData.append('csrf_token', csrfToken);
            
            const response = await fetch(url, { method: 'POST', credentials: 'include', body: formData });
            if (!response.ok) throw new Error(`Network response was not ok. Status: ${response.status}`);
            
            const resultJson = await response.json();
            const scrapedData = startPhase3_ExtractFromJson(resultJson, failedTestNumber);
            startPhase4_FinalUIUpdate(submissionId, { success: true, data: scrapedData });
        } catch (error) {
            startPhase4_FinalUIUpdate(submissionId, { success: false, error: error });
        }
    };
    
    const startPhase3_ExtractFromJson = (json, failedTestNumber) => {
        const inputKey = `input#${failedTestNumber}`;
        const outputKey = `output#${failedTestNumber}`;
        const answerKey = `answer#${failedTestNumber}`;
        const checkerLogKey = `checkerStdoutAndStderr#${failedTestNumber}`;
        return {
            input: json[inputKey]?.trim() ?? '[Not Available]',
            output: json[outputKey]?.trim() ?? '[Not Available]',
            answer: json[answerKey]?.trim() ?? '[Not Available]',
            checkerLog: json[checkerLogKey]?.trim() ?? '[Not Available]',
        };
    };
    
    const startPhase4_FinalUIUpdate = (submissionId, result) => {
    const row = document.querySelector(`tr[data-submission-id="${submissionId}"]`);
    if (!row) return;

    // Use the robust class selector instead of a fragile index.
    const verdictCell = row.querySelector('.status-verdict-cell');
    if (!verdictCell) return;
    
    // Remove the "(Analyzing...)" text
    const analyzingSpan = verdictCell.querySelector(`.${ANALYZING_TEXT_SPAN_CLASS}`);
    if (analyzingSpan) analyzingSpan.remove();
    
    if (result.success) {
        // This is useful for your own debugging, so we can keep it.
        console.table(result.data); 

        const button = document.createElement('button');
        button.className = COPY_BUTTON_CLASS;
        button.textContent = 'Copy Input'; // More user-friendly text
        button.title = 'Copy the failing test case input to clipboard';


        // <<< TASK 1 IMPLEMENTATION: Add click listener to copy data.

        button.addEventListener('click', (e) => {
            // Prevent the click from navigating or triggering other events on the row.
            e.preventDefault();
            e.stopPropagation();
            
            // Use the modern Clipboard API to copy the input text.
            navigator.clipboard.writeText(result.data.input).then(() => {
                // On success, provide permanent feedback to the user.
                button.textContent = 'Copied!';
                

                // <<< TASK 2 IMPLEMENTATION: The setTimeout is removed.
                // The button text will now stay as "Copied!" permanently.

            }).catch(err => {
                // In case of an error (e.g., browser permissions), log it.
                console.error('[AI SOLVER] Could not copy text: ', err);
                button.textContent = 'Copy Failed';
            });
        });

        // Add the fully configured button to the page.
        verdictCell.appendChild(button);

    } else {
        // This part for handling a failed scrape remains the same.
        console.error('[AI SOLVER] Scrape failed.', result.error);
        const errorSpan = document.createElement('span');
        errorSpan.className = `${ANALYZING_TEXT_SPAN_CLASS} error`;
        errorSpan.textContent = ' (Failed)';
        verdictCell.appendChild(errorSpan);
    }
};


    // <<< FIX #3: A more robust selector for finding the table body.

    const tableBody = document.querySelector('.datatable tbody');
    if (!tableBody) {
        console.error('[AI SOLVER] Could not find the submission table body. Extension will not run.');
        return;
    }
    const observer = new MutationObserver(onMutation);
    const observerConfig = {
        childList: true,
        subtree: true,
        characterData: true
    };
    observer.observe(tableBody, observerConfig);

    handleVerdictCheck();
    console.log('[AI SOLVER] Extension loaded and actively monitoring submissions.');
};

    //  MAIN SCRIPT ROUTER

// --- AFTER THE FIX ---
const main = () => {
    const url = window.location.href;

    if (url.includes('/submit')) {
        initSubmitPageLogic();
    } else if (url.includes('/status') || url.includes('/my')) {
        // Only call initStatusPageLogic. It is now the single point of entry
        // for all status page functionality.
        initStatusPageLogic(); 
    } else if (document.querySelector('.problem-statement')) {
        waitForElement(
            ".problem-statement .title, .problem-frames-wrapper .title, div.header > div.title",
            injectSolveButton
        );
    }
};

    // Kick things off
    main();
})();

--- .\extension\injector.js ---
// File: extension/injector.js
// This script runs in the page's own context, not the isolated content script world.
// It has direct access to the page's 'window' object, including the 'ace' editor.

window.addEventListener('pasteSolutionIntoCodeforcesEditor', (event) => {
    const codeToPaste = event.detail.code;
    if (!codeToPaste) return;

    try {
        // This is the command that MUST run in the page's context.
        const editor = window.ace.edit('editor');
        if (editor) {
            editor.setValue(codeToPaste, 1); // 1 moves cursor to end
            editor.clearSelection();
            console.log('[INJECTED SCRIPT] Successfully pasted code via ACE API.');
        } else {
             console.error('[INJECTED SCRIPT] Could not get ACE editor instance.');
        }
    } catch (e) {
        console.error('[INJECTED SCRIPT] Error while pasting:', e);
    }
});

--- .\extension\popup.css ---
/* Styling for the extension's popup window */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    width: 250px; /* A standard width for popups */
    padding: 10px 15px;
    text-align: center;
    background-color: #f4f6f9;
    margin: 0;
}

h1 {
    font-size: 16px;
    color: #333;
    margin: 0 0 10px 0;
}

p {
    font-size: 13px;
    color: #555;
    margin: 0;
}

hr {
    border: 0;
    height: 1px;
    background-color: #e0e0e0;
    margin: 15px 0;
}

.status {
    font-size: 12px;
    color: #777;
}

--- .\extension\popup.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codeforces AI Solver</title>
    <!-- Link to our dedicated stylesheet -->
    <link rel="stylesheet" href="popup.css">
</head>
<body>
    <h1>Codeforces AI Solver</h1>
    <p>The "Solve with AI" button is automatically injected on problem pages.</p>
    
    <hr>

    <p class="status">Version 0.1.0</p>

    <!-- Link to our dedicated logic script -->
    <script src="popup.js"></script>
</body>
</html>








--- .\extension\popup.js ---
/**
 * popup.js
 * 
 * Handles the logic for the extension's popup window.
 * 
 * Phase 1 Responsibilities:
 * - None, as there are no interactive elements in the popup yet.
 * 
 * Future Responsibilities (as per the mind map):
 * - Handle clicks on buttons (e.g., a "Settings" button).
 * - Send messages to the background script or content scripts.
 */

// This event listener waits for the popup's HTML to be fully loaded
// before running any code. It's a best practice.
document.addEventListener('DOMContentLoaded', () => {
    console.log("Popup opened and its script is running.");

    // In the future, we would add our event listeners here.
    // For example:
    // const settingsButton = document.getElementById('settings-btn');
    // settingsButton.addEventListener('click', () => {
    //   chrome.runtime.sendMessage({ type: 'openSettings' });
    // });
});

--- .\extension\style.css ---
/* 
 * =======================================================
 *  Codeforces Verdict Highlighter Styles (CORRECTED)
 * =======================================================
 */

/* =================================================================
 *  <<< FIX: All 'td' selectors are now more specific to win CSS conflicts.
 * ================================================================= */

/*
 * Phase 1: The initial "tracking" style.
 */
.cf-highlighter-tracking {
  border: 2px solid #333333 !important;
  transition: border 0.3s ease-in-out;
}

/* CORRECTED SELECTOR for the background color */
.status-frame-datatable tr.cf-highlighter-tracking td {
  background-color: #f5f5f5 !important; 
  transition: background-color 0.3s ease-in-out;
}

/* 
 * Phase 2 Final State: Accepted Verdict
 */
.cf-highlighter-accepted {
  border: 2px solid #009900 !important;
}

/* CORRECTED SELECTOR for the background color */
.status-frame-datatable tr.cf-highlighter-accepted td {
  background-color: #e8f8e8 !important;
}

/* 
 * Phase 2 Final State: Rejected Verdict (WA, TLE, etc.)
 */
.cf-highlighter-rejected {
  border: 2px solid #d10000 !important;
}

/* CORRECTED SELECTOR for the background color */
.status-frame-datatable tr.cf-highlighter-rejected td {
  background-color: #fff0f0 !important;
}


/* --- Other styles remain the same, they are not part of the issue --- */

.cf-highlighter-status-indicator {
  color: #888888;
  font-style: italic;
  font-size: 0.9em;
}

.cf-highlighter-copy-btn {
  margin-left: 8px;
  padding: 2px 6px;
  font-size: 11px;
  font-weight: bold;
  color: #3B5998;
  background-color: #f5f5f5;
  border: 1px solid #cccccc;
  border-radius: 3px;
  cursor: pointer;
  vertical-align: middle;
  transition: all 0.2s ease;
}

.cf-highlighter-copy-btn:hover {
  background-color: #e8e8e8;
  border-color: #aaaaaa;
}

--- .\server\index.js ---
// File: server/index.js (The new, cleaner version)

require('dotenv').config();
const express = require('express');
const cors = require('cors');
const corsOptions = require('./config/corsOptions');

// Import our new router
const solveRoutes = require('./routes/solveRoutes');

const app = express();

// --- MIDDLEWARE SETUP ---
app.use(cors(corsOptions));
app.use(express.json());

// --- API ENDPOINTS / ROUTES ---

// A simple test route to make sure the server is alive
app.get('/', (req, res) => {
  res.send('Backend Server is alive!');
});

// Use the solveRoutes for any request to /api/solve
app.use('/api/solve', solveRoutes);

// --- START THE SERVER ---
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});

--- .\server\config\corsOptions.js ---
// A more robust and clear CORS configuration
const corsOptions = {
  origin: (origin, callback) => {
    // Allow requests with no origin (like Postman, server-to-server)
    // OR requests from any Chrome extension
    if (!origin || origin.startsWith('chrome-extension://')) {
      callback(null, true);
    } else {
      callback(new Error('This origin is not allowed by CORS'));
    }
  },
  optionsSuccessStatus: 200 // For legacy browser support
};

module.exports = corsOptions;

--- .\server\routes\solveRoutes.js ---
// File: server/routes/solveRoutes.js (FINAL, REFINED & CONFIRMED)

const express = require('express');
const router = express.Router();
const { getAiSolution } = require('../services/aiService');

// This route handles all POST requests to /api/solve from the extension.
router.post('/', async (req, res) => {
  console.log('--- Request received at /api/solve ---');

  // 1. Validate the incoming request body to ensure it has the required data.
  const problemData = req.body;
  if (!problemData || !problemData.title || !problemData.statement) {
    console.error('Validation Failed: Request body is missing title or statement.');
    // If validation fails, send a "400 Bad Request" response and stop.
    return res.status(400).json({ error: 'Invalid request body. Missing title or statement.' });
  }

  console.log(`Received request for problem: "${problemData.title}"`);

  // 2. Call the AI service inside a try...catch block.
  // This is the server's safety net that prevents it from crashing if the AI call fails.
  try {
    // We await the solution from our resilient aiService.
    const solutionCode = await getAiSolution(problemData);
    
    // If successful, package the solution into the standard JSON response format.
    const responsePayload = {
      solution: solutionCode
    };

    console.log('--- Successfully generated solution. Sending 200 OK response. ---');
    res.status(200).json(responsePayload);

  } catch (error) {
    // This block executes ONLY if getAiSolution throws an error.
    console.error("--- Error in /api/solve handler. The AI service failed. Sending 500 Internal Server Error. ---");
    console.error("Error details from AI Service:", error.message);

    // Send a structured error message back to the Chrome extension.
    res.status(500).json({ 
      error: "An internal server error occurred on the server while contacting the AI.",
      details: error.message // This includes the specific reason (e.g., model not found, safety block).
    });
  }
});

module.exports = router;

--- .\server\services\aiService.js ---
// File: server/services/aiService.js (FINAL - Corrected Model Name)

const { GoogleGenerativeAI } = require('@google/generative-ai');
const { buildOptimalPrompt } = require('./promptBuilder');
const { parseCodeFromResponse } = require('./responseParser');

// Initialize the Google AI Client
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

/**
 * The main service function. It orchestrates the entire process of getting a solution.
 * @param {object} problemData - The scraped data from the extension.
 * @returns {Promise<string>} A promise that resolves with the final, clean AI-generated code.
 */
async function getAiSolution(problemData) {
  // The entire function is wrapped in a try...catch to handle any unexpected errors,
  // especially from the API call.
  try {
    // 1. Build the optimal prompt.
    const prompt = buildOptimalPrompt(problemData);
    console.log("AI_Service: Prompt built successfully.");

    // 2. Call the AI library's function.
    // --- THIS IS THE ONLY LINE THAT HAS BEEN CHANGED ---
    const modelName = "gemini-1.5-flash-latest"; // Using a stable, recommended model name.
    
    console.log(`AI_Service: Using Google Gemini model: ${modelName}`);
    console.log("AI_Service: Sending request to Google Gemini...");
    
    const model = genAI.getGenerativeModel({ model: modelName });
    const result = await model.generateContent(prompt);
    const response = await result.response;
    
    // This critical check handles cases where Gemini blocks the response for safety.
    if (!response || !response.text()) {
        const finishReason = response?.promptFeedback?.blockReason || 'No content';
        const safetyRatings = response?.candidates?.[0]?.safetyRatings || 'N/A';
        console.error(`AI_Service: Gemini response was empty or blocked. Reason: ${finishReason}`);
        console.error(`AI_Service: Safety Ratings: ${JSON.stringify(safetyRatings)}`);
        // We throw a specific error that the route handler can catch.
        throw new Error(`The AI service returned an empty or blocked response. Reason: ${finishReason}`);
    }
    
    const rawSolution = response.text();
    console.log("AI_Service: Response received from Google Gemini.");

    // 3. Get the code back by refining and cleaning it.
    const cleanSolution = parseCodeFromResponse(rawSolution);
    return cleanSolution;

  } catch (error) {
    // This block catches errors from the API call (e.g., network issues, invalid API key)
    // or the custom error we threw above for safety blocks.
    console.error("AI_Service: An error occurred within getAiSolution:", error.message);
    
    // Re-throw the error so the calling function (solveRoutes.js) knows something went wrong.
    throw error;
  }
}

module.exports = { getAiSolution };

--- .\server\services\promptBuilder.js ---
// File: server/services/promptBuilder.js

/**
 * Builds a high-quality, optimal prompt to send to the Gemini model,
 * incorporating role-playing, constraints, the problem statement, and formatting rules.
 * @param {object} problemData - The scraped data from the extension.
 * @returns {string} The fully-formed prompt string.
 */
function buildOptimalPrompt(problemData) {
  // 1. Role Playing: Prime the AI to act as an expert.
  const rolePlaying = "You are a world-class competitive programmer and an expert C++ algorithmist. You are known for writing clean, efficient, and correct code.";

  // 2. The Task & Constraints: Give clear, direct instructions.
  const taskAndConstraints = "Your task is to solve the following programming problem. The solution must be a single, complete, runnable C++ program that reads from standard input and writes to standard output.";
  
  // 3. Formatting Instructions: This is crucial for easy parsing.
  const formatting = "Your response MUST contain ONLY the C++ code. Do not include any introductory text, explanations, analysis, or concluding remarks. The entire response should be the raw source code, optionally inside a ```cpp markdown block.";

  // 4. Assembling the context from the problem data.
  const problemContext = `
--- PROBLEM TITLE ---
${problemData.title}

--- PROBLEM STATEMENT ---
${problemData.statement}

--- SAMPLE CASES ---
${problemData.samples.map((sample, index) => `
Sample Input ${index + 1}:
${sample.input}
Sample Output ${index + 1}:
${sample.output}`).join('\n')}
`;

  // Combine all parts into the final prompt.
  const finalPrompt = `
${rolePlaying}

${taskAndConstraints}

${formatting}
${problemContext}
--- YOUR C++ SOLUTION CODE ---
`;

  return finalPrompt.trim();
}

module.exports = { buildOptimalPrompt };

--- .\server\services\responseParser.js ---
// File: server/services/responseParser.js

/**
 * Cleans the raw text response from the AI to extract only the C++ code block.
 * It intelligently handles markdown blocks and other conversational text.
 * @param {string} rawResponse - The text response from the Gemini API.
 * @returns {string} The cleaned, pure C++ code.
 */
function parseCodeFromResponse(rawResponse) {
  if (!rawResponse) {
    return "// Error: Received an empty or null response from the AI.";
  }

  // Priority 1: Look for a C++ markdown block (```cpp ... ```)
  const cppBlockMatch = rawResponse.match(/```cpp([\s\S]*?)```/);
  if (cppBlockMatch && cppBlockMatch[1]) {
    return cppBlockMatch[1].trim();
  }

  // Priority 2: Look for a generic markdown block (``` ... ```)
  const genericBlockMatch = rawResponse.match(/```([\s\S]*?)```/);
  if (genericBlockMatch && genericBlockMatch[1]) {
    // Sometimes a generic block might still have a language hint on the first line.
    // e.g., ```c++\n#include...
    const code = genericBlockMatch[1];
    return code.replace(/^(cpp|c\+\+)\s*\n/, '').trim(); // Remove the language hint if it exists
  }

  // Priority 3: If no markdown block is found, assume the entire response is code.
  // This is a fallback in case the AI doesn't follow formatting instructions perfectly.
  return rawResponse.trim();
}

module.exports = { parseCodeFromResponse };

